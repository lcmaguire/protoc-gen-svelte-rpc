#!/usr/bin/env -S npx tsx

// #!/usr/bin/env -S npx tsx is required in addition to chmod 755 on your plugin to get it working locally.

import { createEcmaScriptPlugin, runNodeJs } from "@bufbuild/protoplugin";
import {
  literalString,
  makeJsDoc,
  localName,
  findCustomMessageOption,
} from "@bufbuild/protoplugin/ecmascript";
import { DescField, DescMessage, DescMethod, DescService, FieldDescriptorProto, MethodKind, ScalarType } from "@bufbuild/protobuf";
import type { Schema } from "@bufbuild/protoplugin/ecmascript";

export const genMessage = "<!-- this file was generated by protoc-gen-svelte-rpc do not edit-->"


const protocGen = createEcmaScriptPlugin({
  name: "protoc-gen-svelte-rpc",
  version: `v0.2.1`,
  parseOption,
  generateTs,
});

runNodeJs(protocGen);

function parseOption(key: string, value: string | undefined) {

}

function generateTs(schema: Schema) {
  // schema.targets.
  // for each file
  for (let i = 0; i < schema.files.length; i++) {
    let file = schema.files[i]
    for (let j = 0; j < file.services.length; j++) {
      let service = file.services[j]
      //genClientFile(schema, service) // gens client for service.
      for (let k = 0; k < service.methods.length; k++) {
        let method = service.methods[k]
        generateView(schema, method.input)
      }
    }
  }
}

function generateCode(schema: Schema, message: DescMessage) {
  //generateViewForType(schema, message, "View")
  //generateRequestView(schema, message)
  generateView(schema, message)
  //let nf = schema.generateFile(message.name + ".md")

  //for (let a in message.fields) {
  //  nf.print(message.fields[a].name)
  //}
}


function generateView(schema: Schema, message: DescMessage) {
  let nf = schema.generateFile(`lib/message.name.svelte`)
  let messageName = protoCamelCase(message.name)

  let res = ""
  if (message.fields.length == 0) {
    nf.print(res)
    return
  }
  for (let i in message.fields) {
    let currentField = message.fields[i]
    let currentFieldName = protoCamelCase(currentField.name)

    if (currentField.fieldKind == "scalar") {
      res += getScalarView(currentField, currentField.declarationString())
    }
  }

  nf.print(res)
}

// make file / route for method
// edit for req, view for response.

export function generateRequestView(schema: Schema, message: DescMessage) {
  let funcsToGen = [];
  let messagesToImport: string[] = []
  let messageName = protoCamelCase(message.name) // todo this could wig some stuff out.


  let res = ""
  for (let i in message.fields) {
    let currentField = message.fields[i]
    let currentFieldName = protoCamelCase(currentField.name)

    let start = ""
    let body = ""
    let end = ""

    let spacing = ``
    if (currentField.repeated) {
      spacing += `    `
      start = `<label for="${protoPathToCssPath(currentFieldName)}"> ${currentFieldName} </label><br>`
      start += `{#if ${messageName}.${currentFieldName} != null}\n`
      start += `  {#each ${messageName}.${currentFieldName} as ${currentFieldName}, key}\n`
      end = `${spacing}<button on:click={() => remove${currentFieldName}Array(key)}> Remove from ${currentFieldName}</button><br>\n`

      end += `  {/each}\n`
      end += `{/if}\n`
      end += `<button on:click={push${currentFieldName}Array}> Add to ${currentFieldName}</button>\n`

      funcsToGen.push(generateArrayFunctions(currentFieldName, messageName, defaultRepeatedValue(currentField)))

    } else {
      currentFieldName = `${messageName}.${currentFieldName}`
    }

    if (currentField.enum != undefined) {
      body += `<label for="${protoPathToCssPath(currentFieldName)}"> ${currentFieldName} </label>\n`
      body += spacing + editEnumView(currentField, currentFieldName)

    } else if (currentField.message != undefined) {
      messagesToImport.push(protoCamelCase(currentField.message!.name))
      body = spacing + editMessageView(currentField.message!, currentFieldName)

    } else {
      if (!currentField.repeated) {
        body += `<label for="${protoPathToCssPath(currentFieldName)}"> ${currentFieldName} </label>\n`
        body += spacing + editScalarView(currentField, currentFieldName) + "<br>"
      } else {
        body += spacing + editScalarView(currentField, currentFieldName)
      }

    }
    res += start + body + end
  }

  res = res.trim()

  // build html then do imports after.
  let newFile = schema.generateFile(`lib/${messageName}/${messageName}.svelte`)
  newFile.print(genMessage)
  let spacing = `  `
  // svelte component
  newFile.print("<script>")
  newFile.print(`${spacing}// @ts-nocheck`)
  for (let i in messagesToImport) { // todo have this be done for all views.
    let importMessage = messagesToImport[i]
    newFile.print(`${spacing}import ${importMessage} from "$lib/${importMessage}/${importMessage}.svelte";`)
  }

  newFile.print(`${spacing}export let ${messageName} = {};`)
  newFile.print(`${spacing}if (${messageName} == undefined){ ${messageName} = {}}`)

  for (let i in funcsToGen) {
    for (let func in funcsToGen[i]) {
      newFile.print(`${spacing}${funcsToGen[i][func]}`)
    }
  }

  newFile.print("</script>")
  newFile.print("")
  newFile.print(`<div class="${protoPathToCssPath(messageName)}">`)
  newFile.print(res)
  newFile.print("</div>")
  newFile.print("")
}



// generate for all messages.
// for RPC, gen route with req / res

function protoPathToCssPath(messageName: any) {
  throw new Error("Function not implemented.");
}
function generateArrayFunctions(currentFieldName: any, messageName: any, arg2: any): any {
  throw new Error("Function not implemented.");
}

function defaultRepeatedValue(currentField: DescField) {
  if (currentField.message != null) {
    return "{}"
  }

  switch (currentField.scalar) {
    case ScalarType.STRING:
      return `""`
    case ScalarType.BOOL:
      return "false"
    case ScalarType.INT32 || ScalarType.INT64 || ScalarType.UINT32 || ScalarType.UINT64:
      return "0"
  }
  return ""
}

// edit view
function editScalarView(currentField: DescField, currentName: string) {
  switch (currentField.scalar) {
    case ScalarType.STRING:
      return `<input class="${protoPathToCssPath(currentName)}" bind:value={${currentName}} >\n`
    case ScalarType.BOOL:
      return `<input class="${protoPathToCssPath(currentName)}" type=checkbox  bind:checked={${currentName}}>\n`
        ;
    case ScalarType.INT32: case ScalarType.INT64: case ScalarType.UINT32: case ScalarType.UINT64:
      // todo enforce int in UI here
      return `<input class="${protoPathToCssPath(currentName)}" type=number bind:value={${currentName}} min=0 step="1" >\n`
    case ScalarType.FIXED32: case ScalarType.FIXED64: case ScalarType.SFIXED32: case ScalarType.SFIXED64: case ScalarType.DOUBLE: case ScalarType.FLOAT:
      return `<input class="${protoPathToCssPath(currentName)}" type=number bind:value={${currentName}} min=0 >\n`
    default:
      return `<!-- ${currentField.scalar}  ${currentName} -->`
  }
}

function editEnumView(currentField: DescField, currentName: string) {
  let res = `<select bind:value={${currentName}}>\n`
  for (let i = 0; i < currentField.enum!.values.length; i++) {
    res += `<option value="${currentField.enum!.values[i].name}">${currentField.enum!.values[i].name}</option>\n`
  }
  res += `</select><br>\n`
  return res
}

function editMessageView(message: DescMessage, currentName: string) {
  
  //if (message.oneofs.length > 0 ) {
  // support oneofs through something like this.
  //}

  return `<Edit${message.name} bind:${message.name}={${currentName}} />\n`
}

function checkWriteType(viewType: string) {
  return viewType == "Edit"
}

function getScalarView(currentField: DescField, currentName: string) {
  switch (currentField.scalar) {
      case ScalarType.STRING:
          return `<p class="${protoPathToCssPath(currentName)}"> ${currentName} : {${currentName}} </p>\n`
      case ScalarType.BOOL:
          return `<p class="${protoPathToCssPath(currentName)}"> ${currentName} : {${currentName}}  </p>\n`
      case ScalarType.INT32: case ScalarType.INT64: case ScalarType.UINT32: case ScalarType.UINT64: ScalarType.FIXED32;
      case ScalarType.FIXED64: case ScalarType.SFIXED32: case ScalarType.SFIXED64: case ScalarType.DOUBLE: case ScalarType.FLOAT:
          return `<p class="${protoPathToCssPath(currentName)}"> ${currentName} : {${currentName}} </p>\n`
      default:
          return ""
  }
}

function getEnumView(currentField: DescField, currentName: string) {
  return `<p class="${protoPathToCssPath(currentName)}"> ${currentName} : {${currentName}} </p>\n`
}

function getMessageView(message: DescMessage, currentName: string) {
  return `<View${message.name} ${message.name}={${currentName}} />\n`
}

export function protoCamelCase(snakeCase: string): string {
  let capNext = false;
  let a = ""
  for (let i = 0; i < snakeCase.length; i++) {
    let c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        a = a + c
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        a = a + c
        break;
    }
  }
  return a;
}